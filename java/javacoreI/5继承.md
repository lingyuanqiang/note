* 继承的基本思想：基于已有的类创建新的类，继承已存在的类就是复用(继承)这些类的方法，且可以增加新方法和新字段，以适应新情况
  
# 类、超类和子类
* “is-a”关系是继承的一个明显特征
  * 如Employee员工类，经理类Manager可以继承Employee类
  * 经理也是一个员工

## 定义子类
* 使用关键字extends表示继承
* extends表明新类派生于一个已存在的类
* 已存在的类成为 **超类、基类、父类**
* 新类称为 **子类、派生类、孩子类**
``` java
public class Manager extends Employee{
    added methods and fields;
}
```
* 通过扩展超类定义子类的时候，只需指出子类与超类的不同
* 最一般的方法放在超类中，特殊方法放在子类中(通用功能抽取到超类)
``` java
class Employee{
    private String name;
    private double salary;

    public Employee(String name, double salary){
        this.name = name;
        this.salary = salary;
    }

    public String getName(){
        return this.name;
    }
    
    public void setName(String name){
        this.name = name;
    }

    public void setSalary(double salary){
        this.salary = salary;
    }

    public double getSalary(){
        return this.salary;
    }

    public
}

class Manager extends Employee{
    private double bonus;

    public void setBonus(double bonus){
        this.bonus = bonus;
    }
}
```
* Manager继承了Employee，所以可以使用getName, setHireDay等方法
* Employee不能使用Manager中的特殊定义的方法

## 覆盖方法
* 超类方法不适用于子类，课提供一个新的方法来覆盖(override)超类中的方法
* 子类不能直接访问Employee的私有字段
* super是指示编译器调用超类方法的特殊关键字
* 继承 **不会删除** 任何字段和方法，只能 **增加和覆盖**
``` java
public class Manager extends Employee{
    //重写了超类的 getSalary方法
    @override
    public double getSalary(){
        //不能直接访问salary字段，要调用父类的公共借口获取
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }
}
```

## 子类构造器
``` java
public class Manager{
    ...
    public Manager(String name, double salary){
        super(name, salary);
        bonus = 0;
    }
    ...
}
```
* super(name, salary),调用超类Employee中参数为name，salary的构造器
* super调用构造器 **必须是子类构造器的第一条语句**
* 子类构造器不能访问超类私有字段，所有要通过super调用构造器来完成超类私有字段的初始化
* 子类构造器没有显式用super调用超类构造器，将自动调用超类的无参数构造器，即super();如果超类没有无参数构造器，子类又没有显式调用超类的其他构造器，将报错


## 多态
* 多态：对象变量可以指示多种实际类型的现象称为多态，即：**可以将子类的对象赋给超类变量**
* 动态绑定：在运行时能够自动地选择适当的方法
* 不能将超类的引用赋给子类变量
``` java
//多态 子类对象赋给了超类变量
Employee aManager = new Manager("manager", 6000.0);
Employee aEmployee = new Employee("Employee", 3000.0);
//动态绑定
//调用Manager的getSalary方法
aManager.getSalary();
//调用Employee的getSalary方法
aEmployee.getSalary();
```

## 理解方法调用
* 调用过程
  * 编译器查看对象的声明类型和方法名，找出所有方法
  * 确定调用中提供的参数类型，确定方法
  * 如果是private、static、final方法或者构造器，可以准确地知道调用哪个方法，这称为 **静态绑定**，如果调用的方法依赖于隐式参数的实际类型，则需要 **动态绑定**
  * 使用动态绑定调用方法时，虚拟机必须调用变量所引用对象的实际类型对应的方法。如变量实际类型是D类，继承C类，如果D定义了该方法，就调用这个方法，如没有，则在D类中寻找方法，以此类推
* 虚拟机会预先为每个类计算一个方法表，节省搜索时间开销

## 阻止继承：final类和方法
* final修饰类，该类不允许被扩展(继承)
``` java
public final class Executive extends Manager{
    ...
}
```
* 类中的方法用final修饰，子类不能覆盖这个方法
* final类中的所有方法自动地成为final方法(不包括字段)
``` java
public class Employee{
    public final String getName(){
        return name;
    }
}
```

## 强制类型转换
``` java
Employee aEmployee = new Manager("manager", 60000);
//强制转换
Manager aManager = (Manager) aEmployee;
```
* 不能在继承链上进行向下的强制类型转换
  * 例如不能将实际类型为Employee的对象转换为Manager
* 在进行强制转换前，先使用instanceof查看是否能转换成功
``` java
Manager aManager; 
if (aEmployee instanceof Manager){
    aManager = (Manager) aEmployee;
}
```

## 抽象类
* 抽象方法使用abstract关键字修饰，不需要实现
* 包含一个或多个抽象方法的类本省必须被声明为抽象的
* 抽象类可以包含字段和具体的方法
``` java
public abstract class Person{
    private String name;
    public Person(String name){
        this.name = name;
    }
    public abstract String getDescription();
    public String getName(){
        return name;
    }
}
```
* 抽象方法充当占位方法的角色，它们在子类中具体实现
  * 子类可以保留部分或所有抽象方法不实现，但子类也必须是抽象的
  * 实现父类的所有抽象方法(这时子类就不是抽象的)
* 不含抽象方法也可以将类声明为抽象的(abstract)
  * 抽象类 **不能实例化**
  * 可以定义一个抽象类 **对象变量** ，但要引用非抽象子类的对象实例

## 受保护访问
* 仅对本类可见 -- private
* 对外部完全可见 -- public
* 对本包和所有子类可见 -- protected
* 对本包可见 -- 默认，不需要修饰符


# Object：所有类的超类
* java中所有的类默认都扩展了Object，不需要显示的声明

## Object类型的变量
* 可使用Object类型的变量引用 **任何类型的对象**
``` java
// 作为泛型容器
Object obj = new Employee("employee", 6000);
// 强制转换后在使用
Employee e = (Employee) obj;
```
* Object类型的变量只能用于作为各种值的一个 **泛型容器**，想要进行具体的操作，要强制转换成对象的原始类型
* 所有的数组类型，都扩展了Object类

## equals方法
* Object类中的equals方法用于检测一个对象是否等于另一个对象
* Object类中的equals原始实现是，判断两个对象引用是否相等

## 相等测试与继承
* java语言规范要求equals具有以下特性
  * 自反性->非空引用，x.equals(x)应该返回true
  * 对称性->对于任何引用x,y,当且仅当x.equals(y)返回true时，y.equals(x)返回true
  * 传递性->对于任何引用x、y、z，如果x.equals(y)返回true， y.equals(z)返回true，x.equals(z)也应该返回true
  * 一致性->如果x、y引用对象不变，反复调用x.equals(y)结果不变
  * 对于任意非空引用x, x.equals(null)应该返回false

* 实现建议
  * 1.显式参数命名为otherObject
  * 2.检测this与otherObject是否相等
  ``` java
  if (this == otherObject) return true;
  ```
  * 3.otherObject如果为null,返回false
  ``` java
  if (otherObject == null) return false;
  ```
  * 4.比较this与otherObject类
    * equals的语义可以在子类中改变，使用getClass检测
    ``` java
    if (getClass() != otherObject.getClass()) return false;
    ```
    * 所有子类都有相同的相等性语义，使用instanceof检测
    ``` java
    if (!(otherObject instanceof ClassName)) return false;
    ```
  * 将otherObject装换成相应类型的变量
  ``` java
  ClassName other = (ClassName) otherObject;
  ```
  * 根据相等性概念要求来对比较字段
  ``` java
  return field1 == other.field1 && Object.equals(field2, other.field2) && ...;
  ```

  ## hashCode方法
  * 散列码是由对象导出的一个整形值，是没有规律的
  * hashCode定义在Object中，每个对象都有一个默认的散列码，由存储地址得出
  * equals与hashCode的定义必须相容
    * 如果x.equals(y)返回true，那么x.hashCode()必须与y.hashCode()返回相同的值

## toString方法
* 返回表示对象值得字符串
* 对象与一个字符串通过 "+" 连接，编译器会自动调用toString来获得这个对象的字符串描述
* Object类中的toString方法，打印对象的类名和散列码

# 泛型数组列表
* ArrayList 类似于数组，添加或删除元素能够自动调整数组容量
* 是一个有类型参数的泛型类，为了指定元素对象类型，用尖括号将类名括起来追加到ArrayList后面
``` java
ArrayList<Employee> staff = new ArrayList<Employee>();
//可以省去右边类型的参数
ArrayList<Employee> staff1 = new ArrayList<>();
```

## 访问数组列表元素
* 使用get和set方法访问和改变数组的元素
* 可以使用for each循环逐个访问
``` java
for (Employee e: staff){
    statement;
}
```

## java.util.ArrayList<E> 常见API
* ArrayList<E>() 构造一个空数组列表
* ArrayList<E>(int initialCapacity) 用指定容量构造一个空数组列表
* boolean add(E obj) 数组列表末尾追加一个元素
* int size() 放回当前存储在数组列表中的元素个数
* void ensureCapacity(int capacity) 确保数组列表在不重新分配内部存储数组的情况下有足够的容量存储给定数量的元素
* void trimToSize() 将数组列表的存储容量削减到当前大小
* E set(int index, E obj)将obj放置在数组列表指定索引位置，返回之前的内容
* E get(int index) 得到指定索引位置存储的值
* void add(int index, E obj) 后移元素，从而将obj插入到指定索引位置
* E remove(int index) 删除指定索引位置的元素，并将后面的所有元素前移，返回删除元素


# 对象包装器与自动装箱
* 所有的基本类型有一个与之对应的类，这些类称为包装器
* 包装器类不可变，即一旦构造了包装器，就不允许更改包装在其中的值
* 包装器类是final的，不能派生子类
* 泛型的类型参数不允许是基本类型，所以就要用到包装器类
``` java
//Integer是int的包装器类
ArrayList<Integer> list = new ArrayList<>();
```
* 自动装箱
``` java
list.add(3);
//将自动地变换为
list.add(Integer.valueOf(3));
```
* 当一个Integer对象赋给int值时，会自动拆箱
``` java
int n = list.get(i);
//将自动转换成
int n = list.get(i).intValue();
```

## 基本类型对应的包装器类
* int->Integer
* long->Long
* float->Float
* double->Double
* short->Short
* byte->Byte
* char->Character
* boolean->Boolean

## java.lang.Integer API
* int intValue()
  * 将这个Integer对象的值作为一个int返回
* static String toString(int i)
  * 返回一个新的String对象，标志指定数值i的十进制表示
* static String toString(int i, int radix)
  * 返回数值i基于radix参数指定进制的表示
* static int parseInt(String s)
* static int parseInt(String s, int radix)
  * 返回字符串s表示的整数，radix表示进制，默认10进制
* static Integer valueOf(String s)
* static Integer valueOf(String s, int radix)
  * 返回一个新的Integer对象，用字符串s表示的整数初始化，采用radix进制，默认为10进制


# 参数数量可变的方法
