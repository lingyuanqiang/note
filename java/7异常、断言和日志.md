# 处理错误
* 需要考虑可能会出现的错误和问题
  * 用户输入错误
  * 设备错误
  * 物理限制
  * 代码错误

* 如果某个方法不能够采用正常的途径完成，可以通过另外一个路径退出方法，不返回任何值，而是跑出一个封装了错误信息的对象，这个方法会立刻退出，异常处理机制开始搜索能够处理这种异常状况的异常处理器

## 异常分类

* 异常对象都是派生于Throwable类的一个类实例
* 异常层次结构
* Throwable
  * Error(java运行时系统的内部错误和资源耗尽错误)
  * Exception
    * IOException(I/O问题导致的)
    * RuntimeException(其他异常，通常是由编程错误导致的)

* 派生于RuntimeException异常主要有
  * 错误的强制类型转换
  * 数组访问越界
  * 访问null指针
* 不是派生于RuntimeException的异常包括
  * 试图超越文件末尾继续读取数据
  * 试图打开一个不存在的文件
  * 试图根据给定的字符串查找class对象，而这个字符串表示的类并不存在
* 派生于Error类或RuntimeException类的所有异常称为 **非检查型异常**, 所有其他的异常称为 **检查型异常**

## 声明检查型异常
* 在方法的首部指出这个方法可能抛出一个异常,使用 **throws** 关键字，多个异常使用 **,** 隔开
``` java
public FileInputStream(String name) throws FileNotFoundException
public Image loadingImage(String s) throws FileNotFoundException, EOFException
```
* 什么时候需要在方法中用throws子句声明异常
  * 调用了一个抛出检查型异常的方法
  * 检测到一个错误，并且利用throws语句抛出一个检查型异常
  * 程序出现错误
  * java虚拟机或运行时库出现内部错误
* 不需要声明Error继承的异常，和RuntimeException继承的非检查型异常，应该多花时间修正，而不是抛出
* 必须声明所有的检查型异常，或者捕获异常处理

## 如何抛出异常
``` java
String readDate(String name) throws EOFException{
    if (name.length > 100){
        throw new EOFException;
        // throw new EOFException("抛出异常");
    }
}
```
* 如果已有异常类能够满足需求
  * 找到一个合适的异常类
  * 创建这个类的一个对象
  * 将对象抛出

## 创建异常类
* 没有合适的标准异常类，可以自定义
  * 继承Exception或其子类，需要包含两个构造器
    * 默认构造器
    * 包含详细描述信息的构造器

``` java {-line-numbers}
class FileFormatException extends IOException{
    public FileFormatException(){}
    public FileFormatException(String s){
        super(s);
    }
}

String readDate(String name) throws FileFormatException{
    if (name.length > 100){
        throw new FileFormatException;
        // throw new FileFormatException("抛出异常");
    }
}
```

# 捕获异常

## 捕获异常
* 如果方法了某个异常，没有在任何地方捕获，程序就会终止
* 捕获异常，使用try/catch语句块，如果try语句块中的任何代码抛出了catch语句中指定的异常类，那么：
  * 程序将跳过try的其余代码块
  * 程序执行catch块中的代码
* 如果抛出的异常catch中没有，则方法立即退出
``` java
try{
    code;
}catch (ExceptionType e){
    handlerException;
}
```
* 可以直接方法中抛出异常，让调用者处理
``` java
public void read(String filename) throws IOException
```
* 如果调用了一个抛出检查型异常的方法，就必须处理这个异常，或者继续传播这个异常
* 不允许在子类的throws说明符中出现超类方法未列出的异常类

## 捕获多个异常
``` java
try{
    code;
}catch (FileNotFoundException e){
    handlerCode;
}catch (UnknownHostException e){
    handlerCode;
}catch (IOException e){
    handlerCode;
}
```

## finally子句
* 不管是否有异常，finally子句中的代码都会执行，常用来清理资源
``` java
try{
    Code;
}catch (ExceptionType e){
    handlerCode;
}finally {
    Code; //不管是否有异常都会执行
}
```
* 可以只有try和finally语块

## try-with-Resource语句
* java7中新增的语句
* 对于以下代码块
``` java
open a resource
try{

}finally{
    close resource;
}
```
* 如果资源属于实现了AutoCloseable接口的类，java7中可以这样改写
``` java
try(Resource res = ...){
    code;
}
```
* try语块退出时，回自动调用res.close()关闭资源

# 使用异常的技巧
* 异常处理不能代替简单的测试
* 不要过分地细化异常
* 充分利用异常层次结构(寻找合适子类或创建自己的异常类，考虑检查型和非检查型异常的区别)
* 不要压制异常
* 在检测错误时，苛刻要比放任好
* 不要羞于传递异常

# 使用断言
